name: E2E Client Detection

on:
  push:
    branches: [main, master]
  pull_request:
  workflow_dispatch:

jobs:
  # Docker-based E2E tests (existing tests, renamed).
  e2e-docker:
    runs-on: ubuntu-latest
    timeout-minutes: 45

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Kurtosis
        run: |
          echo "deb [trusted=yes] https://apt.fury.io/kurtosis-tech/ /" | \
            sudo tee /etc/apt/sources.list.d/kurtosis.list
          sudo apt update
          sudo apt install -y kurtosis-cli

      - name: Start Kurtosis engine
        run: kurtosis engine start

      - name: Start Ethereum network
        run: |
          kurtosis run --enclave observoor-test \
            github.com/ethpandaops/ethereum-package \
            --args-file e2e/client-detection/network-params.yaml

      - name: Wait for beacon sync
        run: |
          # kurtosis port print returns full URL like http://127.0.0.1:32793
          BEACON_URL=$(kurtosis port print observoor-test cl-1-lighthouse-geth http)
          echo "Beacon URL: $BEACON_URL"
          for i in $(seq 1 60); do
            if curl -sf "$BEACON_URL/eth/v1/node/syncing" 2>/dev/null | jq -e '.data.is_syncing == false' > /dev/null 2>&1; then
              echo "Synced!"
              break
            fi
            echo "Attempt $i..."
            sleep 10
          done

      - name: Get beacon endpoint
        id: beacon
        run: |
          # kurtosis port print returns full URL like http://127.0.0.1:32793
          BEACON_ENDPOINT=$(kurtosis port print observoor-test cl-1-lighthouse-geth http)
          echo "endpoint=$BEACON_ENDPOINT" >> $GITHUB_OUTPUT

      - name: Generate config
        run: |
          sed "s|\${BEACON_ENDPOINT}|${{ steps.beacon.outputs.endpoint }}|g" \
            e2e/client-detection/observoor.yaml.tmpl > config.yaml

      - name: Start ClickHouse + observoor
        run: |
          docker compose up -d
          echo "Waiting for services..."
          sleep 30

      - name: Wait for data
        run: |
          for i in $(seq 1 24); do
            COUNT=$(curl -s http://localhost:8123 --data-binary "SELECT count() FROM sched_on_cpu" 2>/dev/null || echo "0")
            echo "Attempt $i: $COUNT rows"
            if [[ "$COUNT" -gt 100 ]]; then
              break
            fi
            sleep 10
          done

      - name: Run smoke tests
        run: ./e2e/client-detection/smoke-tests.sh

      - name: Collect logs on failure
        if: failure()
        run: |
          docker compose logs > docker-logs.txt
          kurtosis enclave dump observoor-test ./kurtosis-dump || true

      - name: Upload logs
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: docker-failure-logs
          path: |
            docker-logs.txt
            kurtosis-dump/

      - name: Cleanup
        if: always()
        run: |
          docker compose down -v || true
          kurtosis enclave rm -f observoor-test || true
          kurtosis engine stop || true

  # Kubernetes-based E2E tests using KIND with Kurtosis K8s backend.
  e2e-kubernetes:
    runs-on: ubuntu-latest
    timeout-minutes: 60

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install KIND
        run: |
          curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.24.0/kind-linux-amd64
          chmod +x ./kind
          sudo mv ./kind /usr/local/bin/kind

      - name: Install kubectl
        run: |
          # Use fixed version to avoid flaky network issues with stable.txt
          KUBECTL_VERSION="v1.31.0"
          curl -LO --retry 3 --retry-delay 5 "https://dl.k8s.io/release/${KUBECTL_VERSION}/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/kubectl
          kubectl version --client

      - name: Install Kurtosis
        run: |
          echo "deb [trusted=yes] https://apt.fury.io/kurtosis-tech/ /" | \
            sudo tee /etc/apt/sources.list.d/kurtosis.list
          sudo apt update
          sudo apt install -y kurtosis-cli

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.23'
          cache: true

      - name: Install build dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y clang llvm libbpf-dev linux-headers-$(uname -r)

      - name: Build observoor
        run: make docker-build

      - name: Create KIND cluster with eBPF support
        run: |
          kind create cluster --name observoor-e2e --config e2e/kubernetes/kind-config.yaml
          kubectl wait --for=condition=Ready nodes --all --timeout=120s
          kind load docker-image observoor:latest --name observoor-e2e

      - name: Configure Kurtosis for Kubernetes backend
        run: |
          # Configure Kurtosis to use the KIND cluster
          KURTOSIS_CONFIG=$(kurtosis config path)
          cat > "$KURTOSIS_CONFIG" <<EOF
          config-version: 2
          should-send-metrics: false
          kurtosis-clusters:
            docker:
              type: "docker"
            kind-observoor-e2e:
              type: "kubernetes"
              config:
                kubernetes-cluster-name: "kind-observoor-e2e"
                storage-class: "standard"
                enclave-size-in-megabytes: 10
          EOF
          # Set the cluster to use KIND
          kurtosis cluster set kind-observoor-e2e

          # Start gateway first (required for CLI to communicate with K8s engine)
          echo "Starting Kurtosis gateway..."
          nohup kurtosis gateway > /tmp/kurtosis-gateway.log 2>&1 &
          GATEWAY_PID=$!
          echo "Gateway started with PID: $GATEWAY_PID"

          # Wait for gateway to initialize
          sleep 10

          # Start the engine (gateway must be running first for K8s backend)
          echo "Starting Kurtosis engine..."
          kurtosis engine start || {
            echo "First start attempt failed, trying restart..."
            kurtosis engine restart
          }

          # Verify engine is accessible by running a simple command
          echo "Verifying engine is accessible..."
          for i in $(seq 1 30); do
            if kurtosis enclave ls 2>/dev/null; then
              echo "Engine is accessible"
              kurtosis engine status || true
              break
            fi
            if [ $i -eq 30 ]; then
              echo "Engine failed to become accessible"
              echo "=== Gateway log ==="
              cat /tmp/kurtosis-gateway.log || true
              echo "=== Engine status ==="
              kurtosis engine status || true
              exit 1
            fi
            echo "Waiting for engine... (attempt $i)"
            sleep 5
          done

      - name: Start Ethereum network via Kurtosis
        run: |
          kurtosis run --enclave observoor-k8s-test \
            github.com/ethpandaops/ethereum-package \
            --args-file e2e/kubernetes/network-params.yaml

      - name: Wait for beacon sync
        run: |
          BEACON_URL=$(kurtosis port print observoor-k8s-test cl-1-lighthouse-geth http)
          echo "Beacon URL: $BEACON_URL"
          for i in $(seq 1 60); do
            if curl -sf "$BEACON_URL/eth/v1/node/syncing" 2>/dev/null | jq -e '.data.is_syncing == false' > /dev/null 2>&1; then
              echo "Synced!"
              break
            fi
            echo "Attempt $i..."
            sleep 10
          done

      - name: Get beacon endpoint
        id: beacon
        run: |
          # For in-cluster access, use the K8s service name instead of gateway URL
          # Kurtosis creates services in kt-<enclave-name> namespace
          KURTOSIS_NS="kt-observoor-k8s-test"

          # Get the service name and port for the beacon node
          SVC_NAME=$(kubectl get svc -n "$KURTOSIS_NS" -l "kurtosis.com/service-name=cl-1-lighthouse-geth" -o jsonpath='{.items[0].metadata.name}')
          HTTP_PORT=$(kubectl get svc -n "$KURTOSIS_NS" "$SVC_NAME" -o jsonpath='{.spec.ports[?(@.name=="http")].port}')

          # Use cluster-internal DNS name
          BEACON_ENDPOINT="http://${SVC_NAME}.${KURTOSIS_NS}.svc.cluster.local:${HTTP_PORT}"
          echo "In-cluster beacon endpoint: $BEACON_ENDPOINT"
          echo "endpoint=$BEACON_ENDPOINT" >> $GITHUB_OUTPUT

      - name: Deploy ClickHouse and observoor
        env:
          BEACON_ENDPOINT: ${{ steps.beacon.outputs.endpoint }}
        run: ./e2e/kubernetes/scripts/deploy-observoor.sh

      - name: Wait for data collection
        run: |
          echo "Waiting for observoor to collect data..."
          sleep 30
          kubectl -n observoor-test logs -l app.kubernetes.io/name=observoor --tail=50 || true

      - name: Run smoke tests
        run: ./e2e/kubernetes/scripts/run-tests.sh

      - name: Collect logs on failure
        if: failure()
        run: |
          echo "=== Observoor pods ===" > k8s-logs.txt
          kubectl -n observoor-test get pods -o wide >> k8s-logs.txt
          echo "" >> k8s-logs.txt
          echo "=== Observoor logs ===" >> k8s-logs.txt
          kubectl -n observoor-test logs -l app.kubernetes.io/name=observoor --tail=200 >> k8s-logs.txt || true
          echo "" >> k8s-logs.txt
          echo "=== ClickHouse logs ===" >> k8s-logs.txt
          kubectl -n observoor-test logs -l app.kubernetes.io/name=clickhouse --tail=100 >> k8s-logs.txt || true
          echo "" >> k8s-logs.txt
          echo "=== Describe pods ===" >> k8s-logs.txt
          kubectl -n observoor-test describe pods >> k8s-logs.txt || true
          kurtosis enclave dump observoor-k8s-test ./kurtosis-k8s-dump || true

      - name: Upload logs
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: kubernetes-failure-logs
          path: |
            k8s-logs.txt
            kurtosis-k8s-dump/

      - name: Cleanup
        if: always()
        run: |
          kurtosis enclave rm -f observoor-k8s-test || true
          kurtosis engine stop || true
          kind delete cluster --name observoor-e2e || true
